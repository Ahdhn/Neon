{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Neon is a research framework for programming multi-device systems maintained by Autodesk Research . Neon\u2019s goal is to automatically transform user sequential code into, for example, a scalable multi-GPU execution. To reach its goal, Neon takes a domain-specific approach based on the parallel skeleton philosophy (a.k.a parallel patterns). Neon provides a set of domain-specific and programmable patterns that users compose through a sequential programming model to author their applications. Then, thanks to the knowledge of the domain, the patterns and their composition, Neon automatically optimizes the sequential code into an execution optimized for multi-device systems. Currently, Neon targets grid-based computations on multi-core CPUs or single node multi-GPU systems. It is important to keep in mind that Neon is a research project in continuous evolution. So, while we have successfully tested the system with different applications (Finite Difference, Finite Element, Lattice Boltzmann Method), Neon interfaces may change between versions to introduce new capabilities. Warning The documentation is still a work in progress and some sections are still missing or incomplete.","title":"Neon's home"},{"location":"CODE_OF_CONDUCT/","text":"Code of Conduct Our Pledge We as members, contributors, and leaders pledge to make participation in our community a safe, inclusive and harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive and healthy community. Our Standards Our Open Source Community works to: Be kind towards other people which enables us to be empathic to each other Be respectful of differing opinions, viewpoints, and experiences Give and gracefully accept constructive feedback Accept responsibility and apologize to those affected by our mistakes, and learning from the experience Focus on what is best not just for us as individuals, but for the overall community We will not tolerate the following behaviors: + Violent threats or language + The use of sexualized language or imagery, and sexual attention or advances of any kind + Trolling, insulting or derogatory comments, and personal or political attacks + Public or private harassment + Publishing others\u2019 private information, such as a physical or email address, without their explicit permission + Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Code of Conduct"},{"location":"CODE_OF_CONDUCT/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"CODE_OF_CONDUCT/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a safe, inclusive and harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive and healthy community.","title":"Our Pledge"},{"location":"CODE_OF_CONDUCT/#our-standards","text":"Our Open Source Community works to: Be kind towards other people which enables us to be empathic to each other Be respectful of differing opinions, viewpoints, and experiences Give and gracefully accept constructive feedback Accept responsibility and apologize to those affected by our mistakes, and learning from the experience Focus on what is best not just for us as individuals, but for the overall community We will not tolerate the following behaviors: + Violent threats or language + The use of sexualized language or imagery, and sexual attention or advances of any kind + Trolling, insulting or derogatory comments, and personal or political attacks + Public or private harassment + Publishing others\u2019 private information, such as a physical or email address, without their explicit permission + Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"CONTRIBUTING/","text":"Neon\u2019s Community and How to Contribute The Neon team strongly believes in the open-source effort and we welcome and greatly appreciate contributions from the community: proposing new features, filing issues, and contributing code. The rest of the document describes various processes to give your contribution. Providing Suggestions Neon is meant to evolve with feedback from the community, and we greatly appreciate any thoughts on ways to improve the design or features. Please use the enhancement tag to denote issues that are suggestions specifically\u2014this helps us triage and respond appropriately. Filing Bugs As with all software, you may run into bugs. Please submit bugs as regular issues on GitHub\u2014we are regularly monitoring issues and will prioritize and schedule fixes. The best bug reports include a detailed way to reproduce the issue predictably and possibly even a working example demonstrating the issue. Contributing Code There are three main steps for contributing your code to the project. First, sign a Contributor License Agreement, share your goal with the community, write your code following Neon coding standards, and finally, submit a pull request. Here are some more details on each of the steps. Contributor License Agreement (CLA) Before contributing any code to this project, we kindly ask you to sign a Contributor License Agreement (CLA). We can not accept any pull request if a CLA has not been signed. If you are contributing on behalf of yourself, the CLA signature is included as a part of the pull request process. If you are contributing on behalf of your employer, please sign our Corporate Contributor License Agreement . The document includes instructions on where to send the completed forms to. Once a signed form has been received, we can happily review and accept your pull requests. Coordinate With the Community We highly recommend opening an issue on GitHub to describe your goals before starting any coding. This will allow you to get early feedback and avoid multiple parallel efforts. Coding Standard To provide a more uniform code base, we would appreciate it if any new code could follow the coding standard described in this document: CodeConvention.md . Git Workflow We follow the GitFlow development model. If you would like to contribute your code to Neon, you should: - Include your work in a feature branch created from the Neon develop branch. The develop branch contains the latest work in Neon. - Then, create a pull request against the develop branch. Periodically, we merge the develop branch into the main branch and tag a new release. When contributing code, please include appropriate tests as part of the pull request, and follow the same comment and coding style as the rest of the project. Take a look through the existing code for examples of the testing and style practices the project follows.","title":"Contributing"},{"location":"CONTRIBUTING/#neons-community-and-how-to-contribute","text":"The Neon team strongly believes in the open-source effort and we welcome and greatly appreciate contributions from the community: proposing new features, filing issues, and contributing code. The rest of the document describes various processes to give your contribution.","title":"Neon's Community and How to Contribute"},{"location":"CONTRIBUTING/#providing-suggestions","text":"Neon is meant to evolve with feedback from the community, and we greatly appreciate any thoughts on ways to improve the design or features. Please use the enhancement tag to denote issues that are suggestions specifically\u2014this helps us triage and respond appropriately.","title":"Providing Suggestions"},{"location":"CONTRIBUTING/#filing-bugs","text":"As with all software, you may run into bugs. Please submit bugs as regular issues on GitHub\u2014we are regularly monitoring issues and will prioritize and schedule fixes. The best bug reports include a detailed way to reproduce the issue predictably and possibly even a working example demonstrating the issue.","title":"Filing Bugs"},{"location":"CONTRIBUTING/#contributing-code","text":"There are three main steps for contributing your code to the project. First, sign a Contributor License Agreement, share your goal with the community, write your code following Neon coding standards, and finally, submit a pull request. Here are some more details on each of the steps.","title":"Contributing Code"},{"location":"CONTRIBUTING/#contributor-license-agreement-cla","text":"Before contributing any code to this project, we kindly ask you to sign a Contributor License Agreement (CLA). We can not accept any pull request if a CLA has not been signed. If you are contributing on behalf of yourself, the CLA signature is included as a part of the pull request process. If you are contributing on behalf of your employer, please sign our Corporate Contributor License Agreement . The document includes instructions on where to send the completed forms to. Once a signed form has been received, we can happily review and accept your pull requests.","title":"Contributor License Agreement (CLA)"},{"location":"CONTRIBUTING/#coordinate-with-the-community","text":"We highly recommend opening an issue on GitHub to describe your goals before starting any coding. This will allow you to get early feedback and avoid multiple parallel efforts.","title":"Coordinate With the Community"},{"location":"CONTRIBUTING/#coding-standard","text":"To provide a more uniform code base, we would appreciate it if any new code could follow the coding standard described in this document: CodeConvention.md .","title":"Coding Standard"},{"location":"CONTRIBUTING/#git-workflow","text":"We follow the GitFlow development model. If you would like to contribute your code to Neon, you should: - Include your work in a feature branch created from the Neon develop branch. The develop branch contains the latest work in Neon. - Then, create a pull request against the develop branch. Periodically, we merge the develop branch into the main branch and tag a new release. When contributing code, please include appropriate tests as part of the pull request, and follow the same comment and coding style as the rest of the project. Take a look through the existing code for examples of the testing and style practices the project follows.","title":"Git Workflow"},{"location":"CONTRIBUTORS/","text":"Contributors We are extremely thankful to all the contributors to the project. A complete list can be found at GitHub Contributors Page . We also want to thank everyone who contributed to Neon before it was made open source. Since the history of the Neon internal version was not migrated to GitHub, their names may not appear on the GitHub Contributors Page. 1 2 3 4 5 6 Ahmed Mahmoud Ali Hashemi Brooke Dolny Massimiliano Meneghin Nigel Morris Pradeep Kumar Jayaraman Finally, we also want to thank everyone from Autodesk who supported the project and made an open-source Neon a reality.","title":"Contributors"},{"location":"CONTRIBUTORS/#contributors","text":"We are extremely thankful to all the contributors to the project. A complete list can be found at GitHub Contributors Page . We also want to thank everyone who contributed to Neon before it was made open source. Since the history of the Neon internal version was not migrated to GitHub, their names may not appear on the GitHub Contributors Page. 1 2 3 4 5 6 Ahmed Mahmoud Ali Hashemi Brooke Dolny Massimiliano Meneghin Nigel Morris Pradeep Kumar Jayaraman Finally, we also want to thank everyone from Autodesk who supported the project and made an open-source Neon a reality.","title":"Contributors"},{"location":"CodeConvention/","text":"Neon Code Convention General rules : Use doxgen for documentation with Javadoc style comment block i.e., 1 2 3 /** * ... text ... */ Use inline documentation of the function input variables and class members variables e.g., 1 void foo ( int v /**< [in] docs for input parameter v */ ); using namespace is only allowed inside .cpp / .cu files. It\u2019s disallowed in headers. using namespace std is disallowed even in .cpp / .cu files. If you want to save some work, just typedef the type you need from the std namespace, or use auto . For consistency reasons, use using declaration instead of typedef e.g., 1 using UintVector = std :: vector < uint32_t > ; Use only sized types (e.g., int32_t , uint32_t , int16_t ). Conceptually, bool has unknown size, so no size equivalent. char is special and can be used only for C strings (use int8_t otherwise). Don\u2019t use NULL or 0 to initialize pointers. nullptr is part of the language now. Preprocessor definitions are all capitals and may contain _ e.g., c++ #define SOME_DEFINE Don\u2019t use long line comment separator e.g., ///////////// or /*****************/ We use NEON_TRACE , NEON_INFO , NEON_WARNING , NEON_ERROR , and NEON_CRITICAL for logging. Using printf or std::cout is prohibited. NEON_* logging macro rely on spdlog with easy python-like string formatting e.g., 1 2 3 4 5 6 7 8 NEON_INFO ( \"Welcome to spdlog!\" ); NEON_ERROR ( \"Some error message with arg: {}\" , 1 ); NEON_WARNING ( \"Easy padding in numbers like {:08d}\" , 12 ); NEON_CRITICAL ( \"Support for int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}\" , 42 ); NEON_INFO ( \"Support for floats {:03.2f}\" , 1.23456 ); NEON_INFO ( \"Positional args are {1} {0}..\" , \"too\" , \"supported\" ); NEON_INFO ( \"{:<30}\" , \"left aligned\" ); Variable prefixes: Use the following prefixes for variable names based on the scope s , m , g , and k . These are mutually exclusive prefixes, where k takes precedence above the rest. - k for compile-time const variables. - g for global variables, including static global variables. - s for class static variables. - m for member variables in classes (not in structs). In addition p is used for pointers e.g., 1 2 3 4 5 6 //Global Variables: const uint32_t kConstGlobal ; // compile-time-const, so 'k' takes precedence int32_t gSomeGlobal ; // global start with 'g' static int gStaticGlobal ; // Static globals start with 'g' void * gpSomePointer ; // Global variables which is a pointer is prefixed with 'gp' const void * gpPointer2 ; // Not compile-time constant. Functions: Use auto style for function but explicitly defining the return type using trailing arrow e.g., 1 auto getGirdSize () -> int ; Function names should be descriptive: Functions that perform an action should be named after the action it performs e.g., Fbo::clear() , createTextureFromFile() . Getters/Setters should start with get and set Functions names that return a bool should be phrased as a question e.g., isWhite() , doesFileExist() , hasTexture() Function names are lower-camel-case e.g., 1 void someFunction () Classes: Classes should hide their internal data as much as possible. Class names should be Upper Camel case ( UpperCamelClass ) or Lower Camel case ( lowerCamelClass ) 1 2 3 4 5 6 7 8 9 class UpperCamelClass { bool isValid (); // Function names are lower-camel-case static uint32_t sInt ; // Static variables start with 's' static const uint32_t kValue ; // Const static is prefixed with 'k' int32_t mMemberVar ; // Member variables start with 'm' int16_t * mpSomePointer ; // Note that with a pointer variable, \"p\" counts as the first word, so the next letter *is* capitalized }; Header file must be a .h containing only the class declaration i.e., class name, methods\u2019 signature and variables Source file must be a .cpp or .cu and it contains the definition of all methods Templated methods definition must be in separate .h file that is included by the corresponding .h . File name should end with _imp.h File names only contain dot (\u201c.\u201d) before the file extension suffix Each class has it\u2019s own files with same name e.g., Grid class goes into Grid.h , Grid.cpp , and Grid_imp.h The order of public/private members and methods as they appear in the class .h file is: public members public methods private methods private members 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // Grid.h #pragma once namespace Neon :: grid { /** * Grid is the blueprint of creating physical domains */ class Grid { private : int mNumCells = 0 /**< number of cells */ ; public : /** * default constructor */ Grid () = default ; /** * Grid constructor */ Grid ( int & const bool padding /**< [in] Enable memory padding if true */ ); /** * Create new field * @return the new field */ template < typename T /**< Field type */ > auto newField () -> Grid :: Field < T > ; }; } // namespace Neon::grid #include \"Neon/domain/Grid_imp.h\" 1 2 3 4 5 6 7 8 // Grid.cpp #pragma once #include \"Neon/domain/Grid.h\" namspeace Neon :: grid { Grid :: Grid ( int & const bool padding ){ // .... } } // namspeace Neon::grid 1 2 3 4 5 6 7 8 9 //Grid_imp.h #pragma once #include \"Neon/domain/Grid.h\" namspeace Neon :: grid { template < typename T > auto Grid :: newField () -> Grid :: Field < T > { //... } } // namspeace Neon::grid Structs: Use struct only as a data-container. All fields must be public. No member functions are allowed. In-class initialization is allowed. 1 2 3 4 5 6 7 8 9 10 11 //UpperCamelStruct.h struct UpperCamelStruct { int32_t someVar ; // Struct members are lower-camel-case int32_t ** pDoublePointer ; // Double pointer is just a pointer std :: smart_ptr < int > pSmartPtr ; // Smart pointer is a pointer char charArray []; // Array is not a pointer std :: string myString ; // String is a string bool isBoolean ; // bool name implies that it's a bool. 'enable', 'is*', 'has*', etc. Don't use negative meaning (use 'enable' instead of 'disable') uint32_t & refVal ; // Reference is not a pointer }; Enums: Use typed enums (i.e, enum class ) as they are type safe and they automatically define their namespace. When approperiate, each enum class should be followed by utility class with static methods. These utility method provide a toString() funtionality as well as toInt() for easy conversions. 1 2 3 4 5 6 7 8 9 10 //DataView.h enum class DataView : char { standard , internal , boundary }; class DataViewUtils { static auto toString ( DataView d ) -> std :: string ; static auto toInt ( DataView d ) -> int ; }","title":"CodeConvention"},{"location":"CodeConvention/#neon-code-convention","text":"","title":"Neon Code Convention"},{"location":"CodeConvention/#general-rules","text":"Use doxgen for documentation with Javadoc style comment block i.e., 1 2 3 /** * ... text ... */ Use inline documentation of the function input variables and class members variables e.g., 1 void foo ( int v /**< [in] docs for input parameter v */ ); using namespace is only allowed inside .cpp / .cu files. It\u2019s disallowed in headers. using namespace std is disallowed even in .cpp / .cu files. If you want to save some work, just typedef the type you need from the std namespace, or use auto . For consistency reasons, use using declaration instead of typedef e.g., 1 using UintVector = std :: vector < uint32_t > ; Use only sized types (e.g., int32_t , uint32_t , int16_t ). Conceptually, bool has unknown size, so no size equivalent. char is special and can be used only for C strings (use int8_t otherwise). Don\u2019t use NULL or 0 to initialize pointers. nullptr is part of the language now. Preprocessor definitions are all capitals and may contain _ e.g., c++ #define SOME_DEFINE Don\u2019t use long line comment separator e.g., ///////////// or /*****************/ We use NEON_TRACE , NEON_INFO , NEON_WARNING , NEON_ERROR , and NEON_CRITICAL for logging. Using printf or std::cout is prohibited. NEON_* logging macro rely on spdlog with easy python-like string formatting e.g., 1 2 3 4 5 6 7 8 NEON_INFO ( \"Welcome to spdlog!\" ); NEON_ERROR ( \"Some error message with arg: {}\" , 1 ); NEON_WARNING ( \"Easy padding in numbers like {:08d}\" , 12 ); NEON_CRITICAL ( \"Support for int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}\" , 42 ); NEON_INFO ( \"Support for floats {:03.2f}\" , 1.23456 ); NEON_INFO ( \"Positional args are {1} {0}..\" , \"too\" , \"supported\" ); NEON_INFO ( \"{:<30}\" , \"left aligned\" );","title":"General rules:"},{"location":"CodeConvention/#variable-prefixes","text":"Use the following prefixes for variable names based on the scope s , m , g , and k . These are mutually exclusive prefixes, where k takes precedence above the rest. - k for compile-time const variables. - g for global variables, including static global variables. - s for class static variables. - m for member variables in classes (not in structs). In addition p is used for pointers e.g., 1 2 3 4 5 6 //Global Variables: const uint32_t kConstGlobal ; // compile-time-const, so 'k' takes precedence int32_t gSomeGlobal ; // global start with 'g' static int gStaticGlobal ; // Static globals start with 'g' void * gpSomePointer ; // Global variables which is a pointer is prefixed with 'gp' const void * gpPointer2 ; // Not compile-time constant.","title":"Variable prefixes:"},{"location":"CodeConvention/#functions","text":"Use auto style for function but explicitly defining the return type using trailing arrow e.g., 1 auto getGirdSize () -> int ; Function names should be descriptive: Functions that perform an action should be named after the action it performs e.g., Fbo::clear() , createTextureFromFile() . Getters/Setters should start with get and set Functions names that return a bool should be phrased as a question e.g., isWhite() , doesFileExist() , hasTexture() Function names are lower-camel-case e.g., 1 void someFunction ()","title":"Functions:"},{"location":"CodeConvention/#classes","text":"Classes should hide their internal data as much as possible. Class names should be Upper Camel case ( UpperCamelClass ) or Lower Camel case ( lowerCamelClass ) 1 2 3 4 5 6 7 8 9 class UpperCamelClass { bool isValid (); // Function names are lower-camel-case static uint32_t sInt ; // Static variables start with 's' static const uint32_t kValue ; // Const static is prefixed with 'k' int32_t mMemberVar ; // Member variables start with 'm' int16_t * mpSomePointer ; // Note that with a pointer variable, \"p\" counts as the first word, so the next letter *is* capitalized }; Header file must be a .h containing only the class declaration i.e., class name, methods\u2019 signature and variables Source file must be a .cpp or .cu and it contains the definition of all methods Templated methods definition must be in separate .h file that is included by the corresponding .h . File name should end with _imp.h File names only contain dot (\u201c.\u201d) before the file extension suffix Each class has it\u2019s own files with same name e.g., Grid class goes into Grid.h , Grid.cpp , and Grid_imp.h The order of public/private members and methods as they appear in the class .h file is: public members public methods private methods private members 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // Grid.h #pragma once namespace Neon :: grid { /** * Grid is the blueprint of creating physical domains */ class Grid { private : int mNumCells = 0 /**< number of cells */ ; public : /** * default constructor */ Grid () = default ; /** * Grid constructor */ Grid ( int & const bool padding /**< [in] Enable memory padding if true */ ); /** * Create new field * @return the new field */ template < typename T /**< Field type */ > auto newField () -> Grid :: Field < T > ; }; } // namespace Neon::grid #include \"Neon/domain/Grid_imp.h\" 1 2 3 4 5 6 7 8 // Grid.cpp #pragma once #include \"Neon/domain/Grid.h\" namspeace Neon :: grid { Grid :: Grid ( int & const bool padding ){ // .... } } // namspeace Neon::grid 1 2 3 4 5 6 7 8 9 //Grid_imp.h #pragma once #include \"Neon/domain/Grid.h\" namspeace Neon :: grid { template < typename T > auto Grid :: newField () -> Grid :: Field < T > { //... } } // namspeace Neon::grid","title":"Classes:"},{"location":"CodeConvention/#structs","text":"Use struct only as a data-container. All fields must be public. No member functions are allowed. In-class initialization is allowed. 1 2 3 4 5 6 7 8 9 10 11 //UpperCamelStruct.h struct UpperCamelStruct { int32_t someVar ; // Struct members are lower-camel-case int32_t ** pDoublePointer ; // Double pointer is just a pointer std :: smart_ptr < int > pSmartPtr ; // Smart pointer is a pointer char charArray []; // Array is not a pointer std :: string myString ; // String is a string bool isBoolean ; // bool name implies that it's a bool. 'enable', 'is*', 'has*', etc. Don't use negative meaning (use 'enable' instead of 'disable') uint32_t & refVal ; // Reference is not a pointer };","title":"Structs:"},{"location":"CodeConvention/#enums","text":"Use typed enums (i.e, enum class ) as they are type safe and they automatically define their namespace. When approperiate, each enum class should be followed by utility class with static methods. These utility method provide a toString() funtionality as well as toInt() for easy conversions. 1 2 3 4 5 6 7 8 9 10 //DataView.h enum class DataView : char { standard , internal , boundary }; class DataViewUtils { static auto toString ( DataView d ) -> std :: string ; static auto toInt ( DataView d ) -> int ; }","title":"Enums:"},{"location":"about/","text":"About","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"maintainers/","text":"Current Maintainers The current maintainers of project Neon are: Massimiliano Meneghin Ahmed Mahmoud Autodesk Research Autodesk Research","title":"Maintainers"},{"location":"maintainers/#current-maintainers","text":"The current maintainers of project Neon are: Massimiliano Meneghin Ahmed Mahmoud Autodesk Research Autodesk Research","title":"Current Maintainers"},{"location":"learn/advanced-mechanisms/multi-resolution/","text":"","title":"Multi-resolution"},{"location":"learn/examples/mandelbrot/","text":"","title":"Mandelbrot"},{"location":"learn/introduction/01-neon-structure/","text":"Neon Structure","title":"Structure of the Library"},{"location":"learn/introduction/01-neon-structure/#neon-structure","text":"","title":"Neon Structure"},{"location":"learn/introduction/02-the-system-level/","text":"The System Level","title":"The System Level"},{"location":"learn/introduction/02-the-system-level/#the-system-level","text":"","title":"The System Level"},{"location":"learn/introduction/03-the-set-level/","text":"The Set Level","title":"The Set Level"},{"location":"learn/introduction/03-the-set-level/#the-set-level","text":"","title":"The Set Level"},{"location":"learn/introduction/04-the-domain-level/","text":"The Domain Level Neon Domain level\u2019s goal is to provide users with simple mechanisms for some specific domains. Currently, Neon focus on those domains where a regular cartesian discretisations are leveraged. Using a simple example will look ad how the level mechanisms can be used. Working with dense domains Let\u2019s use implicit geometries to showcase some aspect of Neon. We\u2019ll be working on a dense domain on top of whihc we define our implicit geometry, like a simple sphere. In the rest of this page, we\u2019ll be looking at the following tasks: Choosing the hardware for the computation - Neon backend Setting up a dense cartesian domain - Neon grid Initializing a sphere through its sdf - Neon field Expanding the sphere via a level set - Neon map containers Computing the grad of the level set field - Neon stencil containers The complete tutorial is located in the Neon/tutorials/introduction/domainLevel directory. However, in the following, we\u2019ll start with an empty main function in domainLevel.cpp and will guide you step by step in the tutorial. Neon backend : choosing the hardware for the computation First, we specify the hardware we want to use. The selection process is introduced in the Set Level section. Just briefly, through a Neon::Backend object, we declare the runtime type (CUDA streams or OpenMP) and a list of resources IDs. In this example, we target the first GPU in the system as it\u2019s a typical configuration. However, we overbook the GPU three times to showcase the multi-GPU capabilities. Note Performance wise, you should never overbook a GPU. However it is a nice debugging configuration to check multi-GPU mechanism using a single GPU. The resulting code is quite simple. Before exiting we also log some hardware information on the terminal to check that everything is as expected. Neon/tutorials/introduction/domainLevel/domainLevel.cpp 26 27 28 29 30 31 32 33 34 35 36 37 38 39 int main ( int , char ** ) { // Step 1 -> Neon backend: choosing the hardware for the computation Neon :: init (); // auto runtime = Neon::Runtime::openmp; auto runtime = Neon :: Runtime :: stream ; // We are overbooking GPU 0 three times std :: vector < int > gpu_ids { 0 , 0 , 0 }; Neon :: Backend backend ( gpu_ids , runtime ); // Printing some information NEON_INFO ( backend . toString ()); return 0 ; } Warning Remember always to call Neon::init(); to ensure that the Neon runtime has been initialized. The function can be call more than once. Running our first draft of the tutorial produce the following on the terminal: Execution output 1 2 3 4 $ ./tutorial-domainLevel [ 12 :24:56 ] Neon: CpuSys_t: Loading info on CPU subsystem [ 12 :24:57 ] Neon: GpuSys_t: Loading info on GPU subsystem 1 GPU was detected. [ 12 :24:57 ] Neon: Backend_t ( 0x7fffdf107860 ) - [ runtime:stream ] [ nDev:1 ] [ dev0:0 NVIDIARTXA4000 ] In particular, the last line describes the selected backend by providing the type, the number of devices as well as the device name. In this case, we are working on an Nvidia A4000 GPU. Neon grid : setting up the cartesian discretisation Now we define a cartesian discretization for our problem. The main information to provide is: dimension of the discretization box, cells of interest in the discretization box, hardware to be used for any computation. During the grid initialization, a stencil may be seen as an uncommon parameter to provide. The stencil is the union of all the stencils that will be used on the grid. Neon needs to know such parameters because they are critical for many optimization aspects. In our example, the only stencil we use is the Jacobi to compute the grad of a level set. The grid initialization extends the main function in domainLevel.cpp with the following lines: Neon/tutorials/introduction/domainLevel/domainLevel.cpp 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // ... // Step 2 -> Neon grid: setting up a dense cartesian domain const int32_t n = 25 ; Neon :: index_3d dim ( n , n , n ); // Size of the domain const double voxelEdge = 1.0 ; // Size of a voxel edge using Grid = Neon :: domain :: eGrid ; // Selecting one of the grid provided by Neon Neon :: domain :: Stencil gradStencil ([] { // We use a center difference scheme to compute the grad // The order of the points is important, // as we'll leverage the specific order when computing the grad. // First positive direction on x, y and z, // then negative direction on x, y, z respectively. return std :: vector < Neon :: index_3d > { { 1 , 0 , 0 }, { 0 , 1 , 0 }, { 0 , 0 , 1 }, { -1 , 0 , 0 }, { 0 , -1 , 0 }, { 0 , 0 , -1 }}; }()); // Actual Neon grid allocation Grid grid ( backend , // <- Passing the target hardware for the computation dim , // <- Dimension of the regular grid used for the discretizasion. [ & ]( const Neon :: index_3d & ) -> bool { // We are looking for a dense domain, // so we are interested in all the points in the grid. return true ; }, // <- defining the active cells. gradStencil ); // <- Stencil that will be used during computations on the grid // Exporting some information NEON_INFO ( grid . toString ()); grid . ioDomainToVtk ( \"domain\" ); return 0 ; } Running again our tutorial with the added code we obtain the following output: Execution output 1 2 3 4 5 $ ./tutorial-domainLevel [ 12 :54:11 ] Neon: CpuSys_t: Loading info on CPU subsystem [ 12 :54:11 ] Neon: GpuSys_t: Loading info on GPU subsystem 1 GPU was detected. [ 12 :54:11 ] Neon: Backend_t ( 0x7ffc0e6fad20 ) - [ runtime:stream ] [ nDev:1 ] [ dev0:0 NVIDIARTXA4000 ] [ 12 :54:12 ] Neon: [ Domain Grid ] : { eGrid } , [ Background Grid ] : {( 25 , 25 , 25 )} , [ Active Cells ] : { 15625 } , [ Cell Distribution ] : {( 15625 )} , [ Backend ] : { Backend_t ( 0x55e6f57a2c70 ) - [ runtime:stream ] [ nDev:1 ] [ dev0:0 NVIDIARTXA4000 ] } By logging the grid information ( NEON_INFO(grid.toString()); ), we can inspect some information about the grid. The last terminal line shows the selected grid type (eGrid in this case), the dimension of the grid, the number of active cells, as well as the number of cells per hardware device. By calling ioDomainToVtk method, we can also inspect the created domain ( grid ) via Paraview as the code generates a vtk file ( myDomain ). With an application working on a dense domain, the Paraview will show all the cells in the discretization box as active. Moreover, it will show the mapping between cells and hardware devices as reported in the following picture: Neon field : defining data over the cartesian discretisation Let\u2019s now allocate some metadata on top of the cartesian discretization we have just creates. Neon field are the tool for the task. Fields are allocated from a Neon grid. The type of a field depends on the metadata store on each cell. A field can allocate a number of components for each cell. This number of components which we call cardinality is defined when the field is created. Neon/tutorials/introduction/domainLevel/domainLevel.cpp 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //... // Step 3 -> Neon field: initializing a sphere through its signed distance function // Creating a scalar field over the grid. // Inactive cells will get associated with a default value of -100 */ auto sphereSdf = grid . newField < double > ( \"sphereSdf\" , // <- Given name of the field. 1 , // <- Number of field's component per grid point. -100 ); // <- Default value for non active points. const double r = ( n * voxelEdge / 2 ) * .3 ; // Using the signed distance function of a sphere to initialize the field's values // We leverage the forEachActiveCell method to easily iterate over the active cells. sphereSdf . forEachActiveCell ([ & ]( const Neon :: index_3d & idx , int , double & value ) { double sdf = sdfCenteredSphere ( idx , dim , voxelEdge , r ); value = sdf ; }); // Exporting some information of the sdf on terminal and on a vtk file. NEON_INFO ( sphereSdf . toString ()); sphereSdf . ioToVtk ( \"sdf\" , \"sdf\" ); return 0 ; } Neon map containers : expanding the sphere via a level set Let\u2019s now manipulate the sdf to expand zero level set of the sphere. The operation can be simply implemented by adding a constant to all the cells of the grid. The result will be a level set field (not a signed distance function). Until now the values of the sphereSdf field are stored on the host, indeed working on the host side is the only way we can do IO type of operations. The process of moving data to the devices is simple as it requires only a simple mehtod call. Warning All Neon operation related to runnig computation or moving data have a asynchronous semantic. At the domain level it is up to the user to handle any sort of synchronization manually. Neon/tutorials/introduction/domainLevel/domainLevel.cpp 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 // ... // Step 4 -> Neon map containers: expanding the sphere via a level set // loading the sphereSdf to device sphereSdf . updateCompute ( Neon :: Backend :: mainStreamIdx ); // Run a container that ads a value to the sphere sdf // The result is a level set of an expanded sphere (not more a sdf) // We run the container asynchronously on the main stream expandedLevelSet ( sphereSdf , 5.0 ). run ( Neon :: Backend :: mainStreamIdx ); // Moving asynchronously the values of the newly computed level set back // to export the result to vtk. sphereSdf . updateIO ( Neon :: Backend :: mainStreamIdx ); // Waiting for the transfer to complete. backend . sync ( Neon :: Backend :: mainStreamIdx ); // Exporting once again the fiel to vtk sphereSdf . ioToVtk ( \"expandedLevelSet\" , \"expandedLevelSet\" ); return 0 ; } Neon/tutorials/introduction/domainLevel/expandSphere.cu 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template < typename Field > auto expandedLevelSet ( Field & sdf , double expantion ) -> Neon :: set :: Container { return sdf . getGrid (). getContainer ( \"ExpandedLevelSet\" , [ & , expantion ]( Neon :: set :: Loader & L ) { auto & px = L . load ( sdf ); return [ = ] NEON_CUDA_HOST_DEVICE ( const typename Field :: Cell & cell ) mutable { px ( cell , 0 ) -= expantion ; }; }); } Neon stencil containers: computing the grad of the level set field Neon/tutorials/introduction/domainLevel/domainLevel.cpp 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 // ... // Step 5 -> Neon stencil containers: computing the grad of the level set field auto grad = grid . newField < double > ( \"sphereSdf\" , // <- Given name of the field. 3 , // <- Number of field's component per grid point. 0 ); // <- Default value for non active points. Neon :: set :: HuOptions huOptions ( Neon :: set :: TransferMode :: get , true ); sphereSdf . haloUpdate ( huOptions ); computeGrad ( sphereSdf , grad , voxelEdge ). run ( Neon :: Backend :: mainStreamIdx ); grad . updateIO ( Neon :: Backend :: mainStreamIdx ); backend . sync ( Neon :: Backend :: mainStreamIdx ); grad . ioToVtk ( \"grad\" , \"grad\" ); return 0 ; Neon/tutorials/introduction/domainLevel/expandSphere.cu 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 template < typename Field > auto computeGrad ( const Field & sdfField , Field & gradField , double h ) -> Neon :: set :: Container { if ( sdfField . getCardinality () != 1 || gradField . getCardinality () != 3 ){ NEON_THROW_UNSUPPORTED_OPERATION ( \"Wrong cardinality detected.\" ); } return sdfField . getGrid (). getContainer ( \"computeGrad\" , [ & , h ]( Neon :: set :: Loader & L ) { auto & sdf = L . load ( sdfField ); auto & grad = L . load ( gradField , Neon :: Compute :: STENCIL ); const auto twiceOverH = 1. / h ; return [ = ] NEON_CUDA_HOST_DEVICE ( const typename Field :: Cell & cell ) mutable { // Central difference for ( int i = 0 ; i < 3 ; i ++ ) { auto upIdx = i ; auto dwIdx = i + 3 ; auto [ valUp , isValidUp ] = sdf . nghVal ( cell , upIdx , 0 , 0 ); auto [ valDw , isValidDw ] = sdf . nghVal ( cell , dwIdx , 0 , 0 ); if ( ! isValidUp || ! isValidDw ) { grad ( cell , 0 ) = 0 ; grad ( cell , 1 ) = 0 ; grad ( cell , 2 ) = 0 ; break ; } else { grad ( cell , i ) = ( valUp - valDw ) / twiceOverH ; } } }; }); }","title":"The Domain Level"},{"location":"learn/introduction/04-the-domain-level/#the-domain-level","text":"Neon Domain level\u2019s goal is to provide users with simple mechanisms for some specific domains. Currently, Neon focus on those domains where a regular cartesian discretisations are leveraged. Using a simple example will look ad how the level mechanisms can be used.","title":"The Domain Level"},{"location":"learn/introduction/04-the-domain-level/#working-with-dense-domains","text":"Let\u2019s use implicit geometries to showcase some aspect of Neon. We\u2019ll be working on a dense domain on top of whihc we define our implicit geometry, like a simple sphere. In the rest of this page, we\u2019ll be looking at the following tasks: Choosing the hardware for the computation - Neon backend Setting up a dense cartesian domain - Neon grid Initializing a sphere through its sdf - Neon field Expanding the sphere via a level set - Neon map containers Computing the grad of the level set field - Neon stencil containers The complete tutorial is located in the Neon/tutorials/introduction/domainLevel directory. However, in the following, we\u2019ll start with an empty main function in domainLevel.cpp and will guide you step by step in the tutorial.","title":"Working with dense domains"},{"location":"learn/introduction/04-the-domain-level/#neon-backend-choosing-the-hardware-for-the-computation","text":"First, we specify the hardware we want to use. The selection process is introduced in the Set Level section. Just briefly, through a Neon::Backend object, we declare the runtime type (CUDA streams or OpenMP) and a list of resources IDs. In this example, we target the first GPU in the system as it\u2019s a typical configuration. However, we overbook the GPU three times to showcase the multi-GPU capabilities. Note Performance wise, you should never overbook a GPU. However it is a nice debugging configuration to check multi-GPU mechanism using a single GPU. The resulting code is quite simple. Before exiting we also log some hardware information on the terminal to check that everything is as expected. Neon/tutorials/introduction/domainLevel/domainLevel.cpp 26 27 28 29 30 31 32 33 34 35 36 37 38 39 int main ( int , char ** ) { // Step 1 -> Neon backend: choosing the hardware for the computation Neon :: init (); // auto runtime = Neon::Runtime::openmp; auto runtime = Neon :: Runtime :: stream ; // We are overbooking GPU 0 three times std :: vector < int > gpu_ids { 0 , 0 , 0 }; Neon :: Backend backend ( gpu_ids , runtime ); // Printing some information NEON_INFO ( backend . toString ()); return 0 ; } Warning Remember always to call Neon::init(); to ensure that the Neon runtime has been initialized. The function can be call more than once. Running our first draft of the tutorial produce the following on the terminal: Execution output 1 2 3 4 $ ./tutorial-domainLevel [ 12 :24:56 ] Neon: CpuSys_t: Loading info on CPU subsystem [ 12 :24:57 ] Neon: GpuSys_t: Loading info on GPU subsystem 1 GPU was detected. [ 12 :24:57 ] Neon: Backend_t ( 0x7fffdf107860 ) - [ runtime:stream ] [ nDev:1 ] [ dev0:0 NVIDIARTXA4000 ] In particular, the last line describes the selected backend by providing the type, the number of devices as well as the device name. In this case, we are working on an Nvidia A4000 GPU.","title":"Neon backend: choosing the hardware for the computation"},{"location":"learn/introduction/04-the-domain-level/#neon-grid-setting-up-the-cartesian-discretisation","text":"Now we define a cartesian discretization for our problem. The main information to provide is: dimension of the discretization box, cells of interest in the discretization box, hardware to be used for any computation. During the grid initialization, a stencil may be seen as an uncommon parameter to provide. The stencil is the union of all the stencils that will be used on the grid. Neon needs to know such parameters because they are critical for many optimization aspects. In our example, the only stencil we use is the Jacobi to compute the grad of a level set. The grid initialization extends the main function in domainLevel.cpp with the following lines: Neon/tutorials/introduction/domainLevel/domainLevel.cpp 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // ... // Step 2 -> Neon grid: setting up a dense cartesian domain const int32_t n = 25 ; Neon :: index_3d dim ( n , n , n ); // Size of the domain const double voxelEdge = 1.0 ; // Size of a voxel edge using Grid = Neon :: domain :: eGrid ; // Selecting one of the grid provided by Neon Neon :: domain :: Stencil gradStencil ([] { // We use a center difference scheme to compute the grad // The order of the points is important, // as we'll leverage the specific order when computing the grad. // First positive direction on x, y and z, // then negative direction on x, y, z respectively. return std :: vector < Neon :: index_3d > { { 1 , 0 , 0 }, { 0 , 1 , 0 }, { 0 , 0 , 1 }, { -1 , 0 , 0 }, { 0 , -1 , 0 }, { 0 , 0 , -1 }}; }()); // Actual Neon grid allocation Grid grid ( backend , // <- Passing the target hardware for the computation dim , // <- Dimension of the regular grid used for the discretizasion. [ & ]( const Neon :: index_3d & ) -> bool { // We are looking for a dense domain, // so we are interested in all the points in the grid. return true ; }, // <- defining the active cells. gradStencil ); // <- Stencil that will be used during computations on the grid // Exporting some information NEON_INFO ( grid . toString ()); grid . ioDomainToVtk ( \"domain\" ); return 0 ; } Running again our tutorial with the added code we obtain the following output: Execution output 1 2 3 4 5 $ ./tutorial-domainLevel [ 12 :54:11 ] Neon: CpuSys_t: Loading info on CPU subsystem [ 12 :54:11 ] Neon: GpuSys_t: Loading info on GPU subsystem 1 GPU was detected. [ 12 :54:11 ] Neon: Backend_t ( 0x7ffc0e6fad20 ) - [ runtime:stream ] [ nDev:1 ] [ dev0:0 NVIDIARTXA4000 ] [ 12 :54:12 ] Neon: [ Domain Grid ] : { eGrid } , [ Background Grid ] : {( 25 , 25 , 25 )} , [ Active Cells ] : { 15625 } , [ Cell Distribution ] : {( 15625 )} , [ Backend ] : { Backend_t ( 0x55e6f57a2c70 ) - [ runtime:stream ] [ nDev:1 ] [ dev0:0 NVIDIARTXA4000 ] } By logging the grid information ( NEON_INFO(grid.toString()); ), we can inspect some information about the grid. The last terminal line shows the selected grid type (eGrid in this case), the dimension of the grid, the number of active cells, as well as the number of cells per hardware device. By calling ioDomainToVtk method, we can also inspect the created domain ( grid ) via Paraview as the code generates a vtk file ( myDomain ). With an application working on a dense domain, the Paraview will show all the cells in the discretization box as active. Moreover, it will show the mapping between cells and hardware devices as reported in the following picture:","title":"Neon grid: setting up the cartesian discretisation"},{"location":"learn/introduction/04-the-domain-level/#neon-field-defining-data-over-the-cartesian-discretisation","text":"Let\u2019s now allocate some metadata on top of the cartesian discretization we have just creates. Neon field are the tool for the task. Fields are allocated from a Neon grid. The type of a field depends on the metadata store on each cell. A field can allocate a number of components for each cell. This number of components which we call cardinality is defined when the field is created. Neon/tutorials/introduction/domainLevel/domainLevel.cpp 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //... // Step 3 -> Neon field: initializing a sphere through its signed distance function // Creating a scalar field over the grid. // Inactive cells will get associated with a default value of -100 */ auto sphereSdf = grid . newField < double > ( \"sphereSdf\" , // <- Given name of the field. 1 , // <- Number of field's component per grid point. -100 ); // <- Default value for non active points. const double r = ( n * voxelEdge / 2 ) * .3 ; // Using the signed distance function of a sphere to initialize the field's values // We leverage the forEachActiveCell method to easily iterate over the active cells. sphereSdf . forEachActiveCell ([ & ]( const Neon :: index_3d & idx , int , double & value ) { double sdf = sdfCenteredSphere ( idx , dim , voxelEdge , r ); value = sdf ; }); // Exporting some information of the sdf on terminal and on a vtk file. NEON_INFO ( sphereSdf . toString ()); sphereSdf . ioToVtk ( \"sdf\" , \"sdf\" ); return 0 ; }","title":"Neon field: defining data over the cartesian discretisation"},{"location":"learn/introduction/04-the-domain-level/#neon-map-containers-expanding-the-sphere-via-a-level-set","text":"Let\u2019s now manipulate the sdf to expand zero level set of the sphere. The operation can be simply implemented by adding a constant to all the cells of the grid. The result will be a level set field (not a signed distance function). Until now the values of the sphereSdf field are stored on the host, indeed working on the host side is the only way we can do IO type of operations. The process of moving data to the devices is simple as it requires only a simple mehtod call. Warning All Neon operation related to runnig computation or moving data have a asynchronous semantic. At the domain level it is up to the user to handle any sort of synchronization manually. Neon/tutorials/introduction/domainLevel/domainLevel.cpp 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 // ... // Step 4 -> Neon map containers: expanding the sphere via a level set // loading the sphereSdf to device sphereSdf . updateCompute ( Neon :: Backend :: mainStreamIdx ); // Run a container that ads a value to the sphere sdf // The result is a level set of an expanded sphere (not more a sdf) // We run the container asynchronously on the main stream expandedLevelSet ( sphereSdf , 5.0 ). run ( Neon :: Backend :: mainStreamIdx ); // Moving asynchronously the values of the newly computed level set back // to export the result to vtk. sphereSdf . updateIO ( Neon :: Backend :: mainStreamIdx ); // Waiting for the transfer to complete. backend . sync ( Neon :: Backend :: mainStreamIdx ); // Exporting once again the fiel to vtk sphereSdf . ioToVtk ( \"expandedLevelSet\" , \"expandedLevelSet\" ); return 0 ; } Neon/tutorials/introduction/domainLevel/expandSphere.cu 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template < typename Field > auto expandedLevelSet ( Field & sdf , double expantion ) -> Neon :: set :: Container { return sdf . getGrid (). getContainer ( \"ExpandedLevelSet\" , [ & , expantion ]( Neon :: set :: Loader & L ) { auto & px = L . load ( sdf ); return [ = ] NEON_CUDA_HOST_DEVICE ( const typename Field :: Cell & cell ) mutable { px ( cell , 0 ) -= expantion ; }; }); }","title":"Neon map containers: expanding the sphere via a level set"},{"location":"learn/introduction/04-the-domain-level/#neon-stencil-containers-computing-the-grad-of-the-level-set-field","text":"Neon/tutorials/introduction/domainLevel/domainLevel.cpp 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 // ... // Step 5 -> Neon stencil containers: computing the grad of the level set field auto grad = grid . newField < double > ( \"sphereSdf\" , // <- Given name of the field. 3 , // <- Number of field's component per grid point. 0 ); // <- Default value for non active points. Neon :: set :: HuOptions huOptions ( Neon :: set :: TransferMode :: get , true ); sphereSdf . haloUpdate ( huOptions ); computeGrad ( sphereSdf , grad , voxelEdge ). run ( Neon :: Backend :: mainStreamIdx ); grad . updateIO ( Neon :: Backend :: mainStreamIdx ); backend . sync ( Neon :: Backend :: mainStreamIdx ); grad . ioToVtk ( \"grad\" , \"grad\" ); return 0 ; Neon/tutorials/introduction/domainLevel/expandSphere.cu 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 template < typename Field > auto computeGrad ( const Field & sdfField , Field & gradField , double h ) -> Neon :: set :: Container { if ( sdfField . getCardinality () != 1 || gradField . getCardinality () != 3 ){ NEON_THROW_UNSUPPORTED_OPERATION ( \"Wrong cardinality detected.\" ); } return sdfField . getGrid (). getContainer ( \"computeGrad\" , [ & , h ]( Neon :: set :: Loader & L ) { auto & sdf = L . load ( sdfField ); auto & grad = L . load ( gradField , Neon :: Compute :: STENCIL ); const auto twiceOverH = 1. / h ; return [ = ] NEON_CUDA_HOST_DEVICE ( const typename Field :: Cell & cell ) mutable { // Central difference for ( int i = 0 ; i < 3 ; i ++ ) { auto upIdx = i ; auto dwIdx = i + 3 ; auto [ valUp , isValidUp ] = sdf . nghVal ( cell , upIdx , 0 , 0 ); auto [ valDw , isValidDw ] = sdf . nghVal ( cell , dwIdx , 0 , 0 ); if ( ! isValidUp || ! isValidDw ) { grad ( cell , 0 ) = 0 ; grad ( cell , 1 ) = 0 ; grad ( cell , 2 ) = 0 ; break ; } else { grad ( cell , i ) = ( valUp - valDw ) / twiceOverH ; } } }; }); }","title":"Neon stencil containers: computing the grad of the level set field"},{"location":"learn/introduction/05-the-skeleton-level/","text":"The Skeleton Level","title":"The Skeleton Level"},{"location":"learn/introduction/05-the-skeleton-level/#the-skeleton-level","text":"","title":"The Skeleton Level"},{"location":"references/api-documentation/","text":"API Documentation TODO - Add link to doxygen documentation","title":"API Documentation"},{"location":"references/api-documentation/#api-documentation","text":"TODO - Add link to doxygen documentation","title":"API Documentation"},{"location":"references/papers-presentations/","text":"Papers Date Event Title Pdf Bibtex 2022-05-30 IPDPS-22 Neon: A Multi-GPU Programming Model for Grid-based Computations Authors\u2019 Copy Meneghin:2022:NAM Presentations Date Event Title Recordings Slides 2022-03-23 GTC-22 Neon: A Multi-GPU Programming Model for Grid-based Computations Hosted by GTC Hosted by GTC","title":"Papers and Presentations"},{"location":"references/papers-presentations/#papers","text":"Date Event Title Pdf Bibtex 2022-05-30 IPDPS-22 Neon: A Multi-GPU Programming Model for Grid-based Computations Authors\u2019 Copy Meneghin:2022:NAM","title":"Papers"},{"location":"references/papers-presentations/#presentations","text":"Date Event Title Recordings Slides 2022-03-23 GTC-22 Neon: A Multi-GPU Programming Model for Grid-based Computations Hosted by GTC Hosted by GTC","title":"Presentations"},{"location":"references/performance-considerations/","text":"Performance Considerations TODO - add some reference benchmarks","title":"Performance"},{"location":"references/performance-considerations/#performance-considerations","text":"TODO - add some reference benchmarks","title":"Performance Considerations"}]}